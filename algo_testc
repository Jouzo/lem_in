
int     *get_path(p, s, t)
{
    int *path;
    vertice u;

    u = t;
    path.push(t);
    while (u != s)
    {
        path.push(p[u]);
        u = p[u];
    }
    return (path);
}

int     *get_availble_vertices(u, s, t, stage)
{
    vertice *next_vertices;
    next_vertices = get_nexts();
    
    foreach(next_vertices)
    {
        if (next_vertices is in this stage in any of the paths found)
            suppr cette element;
    }
    return next_vefrtices;
}

int     *bfs(G, s, t)
{
    int stage = 0; //keep the count of the stage to know when a vertex is occupied
    Q = list
    Q-> s
    int *path;

    while (Q)
    {
        u = Q->
        next_vertices = get_availble_vertices(u, s, t, stage);
        stage++;
        foreach(next_vertices)
        {
            if (!path[next_vertices])
            {
                path[next_vertices] = u;
                if (u == t)
                    return (path);
                Q-> next_vertices;
            }
        }
    }
    return (-1);
}

int     edmonds_karp()
{
    int *f;
    int count_list = 0;

    p = double list
    
    while (1)
    {
        count_list++;
        p[count_list] = bfs();
        if (p[count_list] == -1)
            return (f);
        get_path(p);
    }

}

peut etre que pour faire moins d'operations, au lieu d'avoir la fonction get_available_vertices 
qui check dans toutes les listes chainée qui representes les paths deja trouvés si a un moment m, un vertex est occupé,
on pourrai garder l'info dans la structure de chaque vertex, pour chaque stage il est dispo ou occupé, dans une liste chainée:
available -> 1 -> 0 -> 0 -> 1 -> 1 -> 1 -> 0
